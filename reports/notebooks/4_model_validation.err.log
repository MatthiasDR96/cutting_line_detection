Traceback (most recent call last):
  File "c:\python39\lib\site-packages\jupyter_cache\executors\utils.py", line 58, in single_nb_execution
    executenb(
  File "c:\python39\lib\site-packages\nbclient\client.py", line 1305, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "C:\Users\matth\AppData\Roaming\Python\Python39\site-packages\jupyter_core\utils\__init__.py", line 166, in wrapped
    return loop.run_until_complete(inner)
  File "c:\python39\lib\asyncio\base_events.py", line 642, in run_until_complete
    return future.result()
  File "c:\python39\lib\site-packages\nbclient\client.py", line 705, in async_execute
    await self.async_execute_cell(
  File "c:\python39\lib\site-packages\nbclient\client.py", line 1058, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "c:\python39\lib\site-packages\nbclient\client.py", line 914, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
# Convert all images and labels
total_rmse = 0
for i, row in df_test.iterrows():

	# Define subplot
	plt.subplot(3, 4, i+1)

	# Get the image path name
	img_path = row["path_names"]

	# Read image
	image = cv2.imread(img_path) 
	image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
	height, width, channels = image.shape

	# Get label
	key = img_path.split('\\')[-1].split('.')[0]
	label_file = open("../data/labels/" + key + ".txt", "r")
	labeldata = label_file.read().split(" ")

	# Get keypoints
	y = [(float(labeldata[4]), float(labeldata[5])), (float(labeldata[6]), float(labeldata[7]))]

	# Define augmentation pipeline
	transform = A.Compose([
		A.Resize(224, 224),
		A.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
		ToTensorV2(),
	], keypoint_params=A.KeypointParams(format='xy', remove_invisible=True))

	# Transform
	transformed = transform(image=image, keypoints=y)
	transformed_image = transformed['image']

	# Get ground truth line
	a1 = 0 if (y[1][0] - y[0][0]) == 0 else (y[1][1] - y[0][1]) / (y[1][0] - y[0][0])
	b1 = y[0][1] - a1*y[0][0]

	# Predict line 
	pred = model(transformed_image.unsqueeze(0).cuda().float()) # Unsqueeze to solve for missing batch dimension
	pred = pred.detach().cpu().numpy()[0]

	# Scale prediction to account for resizing
	pred[0] = pred[0] /224*width
	pred[1] = pred[1] /224*height
	pred[2] = pred[2] /224*width
	pred[3] = pred[3] /224*height

	# Get predicted line
	a2 = 0 if (pred[2] - pred[0]) == 0 else (pred[3] - pred[1]) / (pred[2] - pred[0])
	b2 = pred[1] - a2*pred[0]

	# Draw ground truth and predicted line
	draw_extended_line(image, a1, b1, color=(0, 255, 0), thickness=3)
	draw_extended_line(image, a2, b2, color=(255, 0, 0), thickness=3)

	# Visualize
	cv2.rectangle(image, (int(labeldata[0]), int(labeldata[1])), (int(labeldata[2]), int(labeldata[3])), (255, 0, 0), 1)
	plt.imshow(image)

	# Stop reading
	if i >= 3*4-1: break

# Show
plt.show()
------------------


[1;31m---------------------------------------------------------------------------[0m
[1;31mRuntimeError[0m                              Traceback (most recent call last)
Cell [1;32mIn[7], line 40[0m
[0;32m     37[0m b1 [38;5;241m=[39m y[[38;5;241m0[39m][[38;5;241m1[39m] [38;5;241m-[39m a1[38;5;241m*[39my[[38;5;241m0[39m][[38;5;241m0[39m]
[0;32m     39[0m [38;5;66;03m# Predict line [39;00m
[1;32m---> 40[0m pred [38;5;241m=[39m model([43mtransformed_image[49m[38;5;241;43m.[39;49m[43munsqueeze[49m[43m([49m[38;5;241;43m0[39;49m[43m)[49m[38;5;241;43m.[39;49m[43mcuda[49m[43m([49m[43m)[49m[38;5;241m.[39mfloat()) [38;5;66;03m# Unsqueeze to solve for missing batch dimension[39;00m
[0;32m     41[0m pred [38;5;241m=[39m pred[38;5;241m.[39mdetach()[38;5;241m.[39mcpu()[38;5;241m.[39mnumpy()[[38;5;241m0[39m]
[0;32m     43[0m [38;5;66;03m# Scale prediction to account for resizing[39;00m

File [1;32mc:\python39\lib\site-packages\torch\cuda\__init__.py:216[0m, in [0;36m_lazy_init[1;34m()[0m
[0;32m    212[0m     [38;5;28;01mraise[39;00m [38;5;167;01mAssertionError[39;00m(
[0;32m    213[0m         [38;5;124m"[39m[38;5;124mlibcudart functions unavailable. It looks like you have a broken build?[39m[38;5;124m"[39m)
[0;32m    214[0m [38;5;66;03m# This function throws if there's a driver initialization error, no GPUs[39;00m
[0;32m    215[0m [38;5;66;03m# are found or any other error occurs[39;00m
[1;32m--> 216[0m [43mtorch[49m[38;5;241;43m.[39;49m[43m_C[49m[38;5;241;43m.[39;49m[43m_cuda_init[49m[43m([49m[43m)[49m
[0;32m    217[0m [38;5;66;03m# Some of the queued calls may reentrantly call _lazy_init();[39;00m
[0;32m    218[0m [38;5;66;03m# we need to just return without initializing in that case.[39;00m
[0;32m    219[0m [38;5;66;03m# However, we must not let any *other* threads in![39;00m
[0;32m    220[0m _tls[38;5;241m.[39mis_initializing [38;5;241m=[39m [38;5;28;01mTrue[39;00m

[1;31mRuntimeError[0m: Found no NVIDIA driver on your system. Please check that you have an NVIDIA GPU and installed a driver from http://www.nvidia.com/Download/index.aspx

